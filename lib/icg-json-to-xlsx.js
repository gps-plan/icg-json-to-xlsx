// Generated by CoffeeScript 1.7.1
(function() {
  var Workbook, XLSX, buildWorkbook, datenum, findHeaders, fs, getAttrs, isodate, path, sheetFromJson, _;

  fs = require("fs");

  path = require("path");

  _ = require("lodash");

  XLSX = require('xlsx');

  isodate = require("isodate");

  datenum = function(v, date1904) {
    var epoch;
    if (date1904) {
      v += 1462;
    }
    epoch = Date.parse(v);
    return (epoch - new Date(Date.UTC(1899, 11, 30))) / (24 * 60 * 60 * 1000);
  };

  findHeaders = function(data, lookInFirst) {
    var final, headers, limit;
    limit = lookInFirst || 30;
    headers = [];
    _.each(data, function(r, i) {
      var p;
      for (p in r) {
        if (!_.contains(headers, p)) {
          headers.push(p);
        }
      }
      if (i === (limit - 1)) {
        return false;
      }
    });
    final = _.map(headers, function(h) {
      return h.replace(/^([a-z])/, function(r) {
        return r.toUpperCase();
      }).replace(/\w\_\w/g, function(r) {
        return r[0] + " " + r[2].toUpperCase();
      }).replace(/\w([A-Z])/g, function(r) {
        return r[0] + " " + r[1];
      });
    });
    return final;
  };

  getAttrs = function(data, lookInFirst) {
    var attrs, limit;
    limit = lookInFirst || 30;
    attrs = [];
    _.each(data, function(r, i) {
      var p;
      for (p in r) {
        if (!_.contains(attrs, p)) {
          attrs.push(p);
        }
      }
      if (i === (limit - 1)) {
        return false;
      }
    });
    return attrs;
  };

  sheetFromJson = function(data, opts) {
    var headerObj, headers, range, ws;
    ws = {};
    range = {
      s: {
        c: 10000000,
        r: 10000000
      },
      e: {
        c: 0,
        r: 0
      }
    };
    opts = opts || {};
    if (opts.headers) {
      headers = opts.headers;
    } else {
      headers = findHeaders(data);
    }
    var dateFormat = 0;
    if (opts.dateFormat)
      dateFormat = opts.dateFormat;
    headerObj = {};
    _.each(headers, function(h, idx) {
      var attr;
      attr = opts.attributes[idx];
      if (attr) {
        return headerObj[attr] = h;
      }
    });    
    data.unshift(headerObj);
    _.each(data, function(row, R) {
      var C;
      C = 0;
      _.each(opts.attributes, function(prop) {
        var cell, cell_ref, r, val;
        val = row[prop] || "";
        if (range.s.r > R) {
          range.s.r = R;
        }
        if (range.s.c > C) {
          range.s.c = C;
        }
        if (range.e.r < R) {
          range.e.r = R;
        }
        if (range.e.c < C) {
          range.e.c = C;
        }
        cell = {
          v: val
        };
        if (cell.v == null) {
          return true;
        }
        cell_ref = XLSX.utils.encode_cell({
          c: C,
          r: R
        });
        if (typeof cell.v === "number" || typeof cell.v === "'number'") {
          cell.t = "n";
        } else if (typeof cell.v === "boolean") {
          if (opts.booleanAsInt) {
            cell.t = "n";
            cell.v = (cell.v ? 1 : 0);
          }
          else
            cell.t = "b";
        } else if (cell.v instanceof Date) {
          // console.log("format Date")
          cell.t = "n";
          cell.z = XLSX.SSF._table[14];
          cell.v = datenum(cell.v);
        } else {
          // console.log(cell.v)
          if (/^(\d{2})\/(\d{2})\/(\d{4})$/.test(cell.v)) { // dd/MM/YYYY or MM/dd/YYYY
            cell.t = "n";
            if (dateFormat === 0)
              cell.v = datenum( new Date( Date.UTC( cell.v.substring(6,10), cell.v.substring(3,5) - 1, cell.v.substring(0,2) ) ) ); // dd/MM/YYYY
            else
              cell.v = datenum( new Date( Date.UTC( cell.v.substring(6,10), cell.v.substring(0,2) - 1, cell.v.substring(3,5) ) ) ); // MM/dd/YYYY
            cell.z = XLSX.SSF._table[14]; // m/d/y h:mm
            // console.log("format dd/MM/YYYY")
          } else if (/^(\d{2})\/(\d{2})\/(\d{4}) (\d{2}):(\d{2}):(\d{2})$/.test(cell.v)) { // dd/MM/YYYY hh:nn:ss
            cell.t = "n";
            if (dateFormat === 0)
              cell.v = datenum( new Date( Date.UTC( cell.v.substring(6,10), cell.v.substring(3,5) - 1, cell.v.substring(0,2), cell.v.substring(11,13), cell.v.substring(14,16), cell.v.substring(17,19) ) ) );
            else
              cell.v = datenum( new Date( Date.UTC( cell.v.substring(6,10), cell.v.substring(0,2) - 1, cell.v.substring(3,5), cell.v.substring(11,13), cell.v.substring(14,16), cell.v.substring(17,19) ) ) );
            cell.z = XLSX.SSF._table[22]; // m/d/y h:mm
            // console.log("dd/MM/YYYY hh:nn:ss")
          } else if (/^(\d{4})-(\d{2})-(\d{2})(T(\d{2}):(\d{2}):(\d{2})?(\.\d*)?)?(?:Z|(\+|-)([\d|:]*))?$/.test(cell.v)) { // more "flexible" ISO format
            r = /\d{4}\-[01]\d\-[0-3]\dT[0-2]\d\:[0-5]\d\:[0-5]\d([+-][0-2]\d:[0-5]\d|Z)/;
            if (cell.v.match(r)) {
              cell.t = "n";
              cell.z = XLSX.SSF._table[14];
              cell.v = datenum(isodate(cell.v));
            } else {
              cell.t = "s";
            }
            /*
            if ( (dtTemp.getTime() % (1000*60*60*24)) === 0 ) // hours=0,min=0,sec=0,ms=0 --> day part == date
              cell.z = XLSX.SSF._table[14]; // default date format with std. m/d/y
            else
              cell.z = XLSX.SSF._table[22]; // m/d/y h:mm
            */
            // console.log("format ISO flex")
          } else {
            cell.t = "s";
          }
          // console.log("cell=" + JSON.stringify(cell))
        }
        ws[cell_ref] = cell;
        C++;
      });
    });
    if (range.s.c < 10000000) {
      ws["!ref"] = XLSX.utils.encode_range(range);
    }
    return ws;
  };

  Workbook = function() {
    if (!(this instanceof Workbook)) {
      return new Workbook();
    }
    this.SheetNames = [];
    this.Sheets = {};
  };

  buildWorkbook = function(wb, data, options) {
    var attrs, opts, ws;
    options = options || {};
    if (!options.headers) {
      options.headers = findHeaders(data);
    }
    if (!options.attributes) {
      attrs = getAttrs(data);
      options.attributes = attrs;
    }
    if (!options.outputSheetName) {
      var first_sheet_name;
      if (wb.SheetNames[0])
        first_sheet_name = wb.SheetNames[0];
      else
        first_sheet_name = "Sheet 1";
      options.outputSheetName = first_sheet_name;
    }
    opts = {
      headers: options.headers,
      attributes: options.attributes,
      booleanAsInt: options.booleanAsInt,
      dateFormat: options.dateFormat
    };
    ws = sheetFromJson(data, opts);
    if (!wb.Sheets[options.outputSheetName])
      wb.SheetNames.push(options.outputSheetName);
    wb.Sheets[options.outputSheetName] = ws;
    return wb;
  };

  module.exports = {
    writeFile: function(filename, data, options) {
      var wb;
      if (!filename || !data) {
        throw new Error("filename and data parameters are required.");
      } else {
        options = options || {};
        wb = new Workbook();
        wb = buildWorkbook(wb, data, options);
        XLSX.writeFile(wb, filename);
      }
      return filename;
    },
    writeFileExt: function(filename, data, options) {
      var wb;
      if (!filename || !data) {
        throw new Error("filename and data parameters are required.");
      } else {
        options = options || {};
        if (!options.template)
          wb = new Workbook();
        else {
          wb = XLSX.readFile(options.template);
        }
        if (data instanceof Array) {
          _.each(data, function(sheetData) {
            wb = buildWorkbook(wb, sheetData.data, sheetData.options);
          });
        }
        else
          wb = buildWorkbook(wb, data, options);
        XLSX.writeFile(wb, filename);
      }
      return filename;
    },
    writeBuffer: function(data, options) {
      var buffer, wb;
      buffer = null;
      if (!data) {
        throw new Error("data parameter is required.");
      } else {
        wb = buildWorkbook(data, options);
        buffer = XLSX.write(wb, {
          type: "buffer"
        });
      }
      return buffer;
    }
  };

}).call(this);
